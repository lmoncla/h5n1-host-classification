SUBTYPES = ["h5n1"]
SEGMENTS = ["ha"] #["pb2", "pb1", "pa", "ha", "np", "na", "mp", "ns"]

path_to_fauna = '../fauna'

rule all:
    input:
        auspice_json = expand("auspice/flu_avian_{subtype}_{segment}.json", subtype=SUBTYPES, segment=SEGMENTS)

rule files:
    params:
        dropped_strains = "config/dropped_strains_{subtype}.txt",
        reference = "config/reference_{subtype}_{segment}.gb",
        colors = "config/colors_{subtype}.tsv",
        lat_longs = "config/lat_longs_{subtype}.tsv",
        priorities_file = "config/priorities.txt",
        auspice_config = "config/auspice_config_{subtype}.json",
        fasta = "../metadata-with-annotations/sequences_{subtype}_{segment}-full-genomes-deduped-2020-11-16.fasta",
        metadata = "../metadata-with-annotations/metadata_{subtype}_{segment}-full-genomes-only-2021-05-28.txt"

files = rules.files.params

def group_by(w):
    gb = {'h5n1': 'country month domestic_wild'}
    return gb[w.subtype]

def sequences_per_group(w):
    spg = {'h5n1': '1'}
    return spg[w.subtype]

def min_length(w):
    len_dict = {"pb2": 2100, "pb1": 2100, "pa": 2000, "ha":1600, "np":1400, "na":1270, "mp":900, "ns":800}
    length = len_dict[w.segment]
    return(length)

def min_date(w):
    date = {'h5n1': '1996'}
    return date[w.subtype]

def traits_columns(w):
    traits = {'h5n1': 'region'}
    return traits[w.subtype]

rule filter:
    message:
        """
        Filtering to
          - {params.sequences_per_group} sequence(s) per {params.group_by!s}
          - excluding strains in {input.exclude}
          - samples with missing region and country metadata
          - excluding strains prior to {params.min_date}
        """
    input:
        sequences = files.fasta,
        metadata = files.metadata,
        exclude = files.dropped_strains,
        priorities_file = files.priorities_file
    output:
        sequences = "results/filtered_sequences_{subtype}_{segment}.fasta",
        metadata = "results/filtered_metadata_{subtype}_{segment}.txt"
    params:
        group_by = group_by,
        sequences_per_group = sequences_per_group,
        min_date = min_date,
        min_length = min_length,
        exclude_where = "host=nonhuman\ mammal host=environment host=unknown host=other host=laboratoryderived country=? region=? domestic_wild=environment domestic_wild=nonhuman\ mammal domestic_wild=exclude domestic_wild=''"

    shell:
        """
        augur filter \
            --sequences {input.sequences} \
            --metadata {input.metadata} \
            --exclude {input.exclude} \
            --output-sequences {output.sequences} \
            --output-metadata {output.metadata} \
            --group-by {params.group_by} \
            --sequences-per-group {params.sequences_per_group} \
            --min-date {params.min_date} \
            --exclude-where {params.exclude_where} \
            --min-length {params.min_length} \
            --priority {input.priorities_file}\
            --no-probabilistic-sampling \
            --non-nucleotide
        """

rule filter_seqs_with_incomplete_dates:
    message:
        """
        Filtering to
          - {params.sequences_per_group} sequence(s) per {params.group_by!s}
        """
    input:
        sequences = rules.filter.output.sequences,
        metadata = rules.filter.output.metadata,
    output:
        strains = "results/strains-dates-incomplete_{subtype}_{segment}.txt"
    params:
        group_by = "region domestic_wild year",
        sequences_per_group = 1

    shell:
        """
        augur filter \
            --sequences {input.sequences} \
            --metadata {input.metadata} \
            --output-strains {output.strains} \
            --group-by {params.group_by} \
            --sequences-per-group {params.sequences_per_group} \
            --no-probabilistic-sampling \
            --query "date_resolution == 'year'"
        """

rule select_complete_dates:
    message:
        """
       Selecting all filtered sequences that have year or day resolution
        """
    input:
        sequences = rules.filter.output.sequences,
        metadata = rules.filter.output.metadata,
    output:
        strains = "results/strains-dates-complete_{subtype}_{segment}.txt"

    shell:
        """
        augur filter \
            --sequences {input.sequences} \
            --metadata {input.metadata} \
            --output-strains {output.strains} \
            --query "date_resolution != 'year'"
        """


rule combine_subsampled_files:
    message:
        """
       Combining subsampled files
        """
    input:
        sequences = rules.filter.output.sequences,
        metadata = rules.filter.output.metadata,
        complete_strains = rules.select_complete_dates.output.strains,
        incomplete_strains = rules.filter_seqs_with_incomplete_dates.output.strains
    output:
        sequences = "results/filtered2_sequences_{subtype}_{segment}.fasta",
        metadata = "results/filtered2_metadata_{subtype}_{segment}.txt"

    shell:
        """
        augur filter \
            --sequences {input.sequences} \
            --metadata {input.metadata} \
            --exclude-all \
            --include {input.complete_strains} {input.incomplete_strains} \
            --output-sequences {output.sequences} \
            --output-metadata {output.metadata}
        """

# Subsample a minimal number of North American flu sequences.
# augur filter \
#     --metadata metadata.tsv \
#     --query "region == 'North America'" \
#     --group-by year month \
#     --sequences-per-group 1 \
#     --output-strains strains_north-america.txt
# # Select all sequences from all other regions.
# augur filter \
#     --metadata metadata.tsv \
#     --query "region != 'North America'" \
#     --output-strains strains_non-north-america.txt
# # Extract sequences and metadata from selected strains.
# augur filter \
#     --metadata metadata.tsv \
#     --sequences sequences.fasta \
#     --exclude-all \
#     --include strains_north-america.txt strains_non-north-america.txt \
#     --output-sequences filtered_sequences.fasta \
#     --output-metadata filtered_metadata.tsv


rule align:
    message:
        """
        Aligning sequences to {input.reference}
          - filling gaps with N
        """
    input:
        sequences = rules.combine_subsampled_files.output.sequences,
        reference = files.reference
    output:
        alignment = "results/aligned_{subtype}_{segment}.fasta"
    shell:
        """
        augur align \
            --sequences {input.sequences} \
            --reference-sequence {input.reference} \
            --output {output.alignment} \
            --fill-gaps \
            --remove-reference \
            --nthreads 1
        """

rule tree:
    message: "Building tree"
    input:
        alignment = rules.align.output.alignment
    output:
        tree = "results/tree-raw_{subtype}_{segment}.nwk"
    params:
        method = "iqtree"
    shell:
        """
        augur tree \
            --alignment {input.alignment} \
            --output {output.tree} \
            --method {params.method} \
            --nthreads 1
        """

rule refine:
    message:
        """
        Refining tree
          - estimate timetree
          - use {params.coalescent} coalescent timescale
          - estimate {params.date_inference} node dates
        """
    input:
        tree = rules.tree.output.tree,
        alignment = rules.align.output,
        metadata = files.metadata
    output:
        tree = "results/tree_{subtype}_{segment}.nwk",
        node_data = "results/branch-lengths_{subtype}_{segment}.json"
    params:
        coalescent = "const",
        date_inference = "marginal",
        clock_filter_iqd = 4
    shell:
        """
        augur refine \
            --tree {input.tree} \
            --alignment {input.alignment} \
            --metadata {input.metadata} \
            --output-tree {output.tree} \
            --output-node-data {output.node_data} \
            --timetree \
            --coalescent {params.coalescent} \
            --date-confidence \
            --date-inference {params.date_inference} \
            --clock-filter-iqd {params.clock_filter_iqd}
        """

rule ancestral:
    message: "Reconstructing ancestral sequences and mutations"
    input:
        tree = rules.refine.output.tree,
        alignment = rules.align.output
    output:
        node_data = "results/nt-muts_{subtype}_{segment}.json"
    params:
        inference = "joint"
    shell:
        """
        augur ancestral \
            --tree {input.tree} \
            --alignment {input.alignment} \
            --output-node-data {output.node_data} \
            --inference {params.inference}
        """

rule translate:
    message: "Translating amino acid sequences"
    input:
        tree = rules.refine.output.tree,
        node_data = rules.ancestral.output.node_data,
        reference = files.reference
    output:
        node_data = "results/aa-muts_{subtype}_{segment}.json"
    shell:
        """
        augur translate \
            --tree {input.tree} \
            --ancestral-sequences {input.node_data} \
            --reference-sequence {input.reference} \
            --output {output.node_data}
        """

rule traits:
    message: "Inferring ancestral traits for {params.columns!s}"
    input:
        tree = rules.refine.output.tree,
        metadata = files.metadata
    output:
        node_data = "results/traits_{subtype}_{segment}.json",
    params:
        columns = traits_columns,
    shell:
        """
        augur traits \
            --tree {input.tree} \
            --metadata {input.metadata} \
            --output {output.node_data} \
            --columns {params.columns} \
            --confidence
        """

rule reconstruct_translations:
    message: "Reconstructing translations for DMS data view"
    input:
        tree = rules.refine.output.tree,
        node_data = "results/aa-muts_{subtype}_{segment}.json",
    output:
        aa_alignment = "results/aa-alignment_{subtype}_{segment}.fasta"
    shell:
        """
        augur reconstruct-sequences \
            --tree {input.tree} \
            --mutations {input.node_data} \
            --gene PB2 \
            --output {output.aa_alignment} \
            --internal-nodes
        """

rule export:
    message: "Exporting data files for for auspice"
    input:
        tree = rules.refine.output.tree,
        metadata = files.metadata,
        branch_lengths = rules.refine.output.node_data,
        traits = rules.traits.output.node_data,
        nt_muts = rules.ancestral.output.node_data,
        aa_muts = rules.translate.output.node_data,
        colors = files.colors,
        lat_longs = files.lat_longs,
        auspice_config = files.auspice_config
    output:
        auspice_json = "auspice/flu_avian_{subtype}_{segment}.json"
    shell:
        """
        augur export v2 \
            --tree {input.tree} \
            --metadata {input.metadata} \
            --node-data {input.branch_lengths} {input.traits} {input.nt_muts} {input.aa_muts}\
            --colors {input.colors} \
            --lat-longs {input.lat_longs} \
            --auspice-config {input.auspice_config} \
            --output {output.auspice_json}
        """

rule clean:
    message: "Removing directories: {params}"
    params:
        "results ",
        "auspice"
    shell:
        "rm -rfv {params}"
